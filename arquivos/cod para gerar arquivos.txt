#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <time.h>

#define DADO2_LEN 5000

typedef struct {
    int32_t chave;              // 4 bytes
    int64_t dado1;              // 8 bytes
    char    dado2[DADO2_LEN];   // 5000 bytes (conteúdo bruto)
} Registro;

/* Preenche dado2 com letras A..Z (aleatório) */
static inline void dado2_random(char *buf) {
    for (int i = 0; i < DADO2_LEN; i++)
        buf[i] = (char)('A' + (rand() % 26));
}

/* Preenche dado2 com 'X' (rápido e altamente compressível) */
static inline void dado2_repeated(char *buf) {
    memset(buf, 'X', DADO2_LEN);
}

/* barra de progresso simples no stderr */
static void progress(size_t i, size_t total) {
    if (total >= 100 && (i % (total/100 ? total/100 : 1)) == 0) {
        size_t p = (i * 100) / total;
        fprintf(stderr, "\r%3zu%%", p);
        fflush(stderr);
    }
}

/* ASC: 1..N */
static void gera_asc(const char *nome, size_t N, int use_repeated) {
    FILE *f = fopen(nome, "wb");
    if (!f) { perror("asc fopen"); exit(1); }

    Registro r;
    for (size_t i = 1; i <= N; i++) {
        r.chave = (int32_t)i;
        r.dado1 = (int64_t)i * 2;
        if (use_repeated) dado2_repeated(r.dado2); else dado2_random(r.dado2);
        if (fwrite(&r, sizeof r, 1, f) != 1) { perror("asc fwrite"); exit(1); }
        if ((i & 0x1FFFF) == 0) fflush(f);  // flush periódico
        progress(i, N);
    }
    fclose(f);
    fprintf(stderr, "\r100%%\n");
}

/* DESC: N..1 */
static void gera_desc(const char *nome, size_t N, int use_repeated) {
    FILE *f = fopen(nome, "wb");
    if (!f) { perror("desc fopen"); exit(1); }

    Registro r;
    for (size_t i = N; i >= 1; i--) {
        r.chave = (int32_t)i;
        r.dado1 = (int64_t)i * 2;
        if (use_repeated) dado2_repeated(r.dado2); else dado2_random(r.dado2);
        if (fwrite(&r, sizeof r, 1, f) != 1) { perror("desc fwrite"); exit(1); }
        if (((N - i) & 0x1FFFF) == 0) fflush(f);
        progress(N - i + 1, N);
        if (i == 1) break; // evita underflow de size_t
    }
    fclose(f);
    fprintf(stderr, "\r100%%\n");
}

/* Fisher-Yates in-place */
static void fisher_yates(int32_t *v, size_t n) {
    for (size_t i = n - 1; i > 0; i--) {
        size_t j = (size_t)(rand() % (int)(i + 1));
        int32_t tmp = v[i]; v[i] = v[j]; v[j] = tmp;
    }
}

/* MIX: 1..N embaralhado (sem repetição) */
static void gera_mix(const char *nome, size_t N, int use_repeated) {
    FILE *f = fopen(nome, "wb");
    if (!f) { perror("mix fopen"); exit(1); }

    int32_t *keys = (int32_t*)malloc(N * sizeof(int32_t));
    if (!keys) { perror("mix malloc"); exit(1); }
    for (size_t i = 0; i < N; i++) keys[i] = (int32_t)(i + 1);

    fisher_yates(keys, N);

    Registro r;
    for (size_t i = 0; i < N; i++) {
        r.chave = keys[i];
        r.dado1 = (int64_t)r.chave * 2;
        if (use_repeated) dado2_repeated(r.dado2); else dado2_random(r.dado2);
        if (fwrite(&r, sizeof r, 1, f) != 1) { perror("mix fwrite"); exit(1); }
        if ((i & 0x1FFFF) == 0) fflush(f);
        progress(i + 1, N);
    }

    free(keys);
    fclose(f);
    fprintf(stderr, "\r100%%\n");
}

int main(int argc, char **argv) {
    /* uso:
       ./gerar_tres_binarios            -> N = 1000000, filler = random
       ./gerar_tres_binarios 2000000    -> N = 2000000, filler = random
       ./gerar_tres_binarios 2000000 repeated -> N = 2000000, filler = 'X'
    */
    size_t N = (argc > 1 ? strtoull(argv[1], NULL, 10) : 1000000);
    int use_repeated = (argc > 2 && strcmp(argv[2], "repeated") == 0);

    srand((unsigned)time(NULL));

    fprintf(stderr, "sizeof(Registro) = %zu bytes | N=%zu | filler=%s\n",
            sizeof(Registro), N, use_repeated ? "repeated('X')" : "random(A..Z)");

    fprintf(stderr, "[1/3] Gerando registros_asc.bin...\n");
    gera_asc("registros_asc.bin", N, use_repeated);

    fprintf(stderr, "[2/3] Gerando registros_desc.bin...\n");
    gera_desc("registros_desc.bin", N, use_repeated);

    fprintf(stderr, "[3/3] Gerando registros_mix.bin...\n");
    gera_mix("registros_mix.bin", N, use_repeated);

    fprintf(stderr, "Concluído.\n");
    return 0;
}
